#include <Arduino.h>
#include <digitalWriteFast.h>
#include <LightweightServo.h>
#include <ServoEasing.h>
#include <SimpleKalmanFilter.h>

// #define FRONT_SENSOR 1
// #define REAR_SENSOR 0
// #define FRONT_SENSOR_TRIGGER_PIN PB5 //dont touch for safety reasons (5V intolerant when used as input)
// #define FRONT_SENSOR_ECHO_PIN PB4
// #define REAR_SENSOR_TRIGGER_PIN PB3
// #define REAR_SENSOR_ECHO_PIN PA15
#define TOWERSERVO_PIN PB6
#define LEFTSERVO_PIN PB7
#define RIGHTSERVO_PIN PB8

ServoEasing leftservo;
ServoEasing rightservo;
ServoEasing towerservo;

// SimpleKalmanFilter frontSensorFilter(0.152, 0.152, 0.004);
// SimpleKalmanFilter rearSensorFilter(0.152, 0.152, 0.004);

float radarData[36] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

void towerAttach()
{
  towerservo.attach(TOWERSERVO_PIN, DEFAULT_MICROSECONDS_FOR_0_DEGREE, DEFAULT_MICROSECONDS_FOR_180_DEGREE, 2, 197); //datasheet says 1ms to 2ms but defaults are better//DEFAULT_MICROSECONDS_FOR_0_DEGREE, DEFAULT_MICROSECONDS_FOR_180_DEGREE 544,2400
}

void towerDetach()
{
  towerservo.detach();
}

void motorsAttach()
{
  leftservo.attach(LEFTSERVO_PIN, DEFAULT_MICROSECONDS_FOR_0_DEGREE, DEFAULT_MICROSECONDS_FOR_180_DEGREE, 2, 197);
  rightservo.attach(RIGHTSERVO_PIN, DEFAULT_MICROSECONDS_FOR_0_DEGREE, DEFAULT_MICROSECONDS_FOR_180_DEGREE, 2, 197);
}

void motorsDetach()
{
  leftservo.detach();
  rightservo.detach();
}

void setTowerEasingType(uint8_t easingType)
{
  towerservo.setEasingType(easingType);
}

void setMotorsEasingType(uint8_t easingType)
{
  leftservo.setEasingType(easingType);
  rightservo.setEasingType(easingType);
}

int multiMap(int val, int *_in, int *_out, uint8_t size)
{
  // note: the _in array should have increasing values
  //constrain value between boundaries
  if (val <= _in[0])
    return _out[0];
  if (val >= _in[size - 1])
    return _out[size - 1];

  // search right interval
  uint8_t pos = 1; // _in[0] allready tested
  while (val > _in[pos])
    pos++;

  // this will handle all exact "points" in the _in array
  if (val == _in[pos])
    return _out[pos];

  // interpolate in the right segment for the rest
  return (val - _in[pos - 1]) * (_out[pos] - _out[pos - 1]) / (_in[pos] - _in[pos - 1]) + _out[pos - 1];
}

void rotateTower(int degree, uint16_t millisForMove = 200) //degrees 0 to 180, BLOCKING
{
  int in[] = {0, 90, 180};
  int out[] = {0, 84, 180};
  degree = multiMap(degree, in, out, 3);

  towerservo.easeToD(degree, millisForMove);
}

void driveTower(int degree, uint16_t millisForMove = 1000) //degrees 0 to 180, NON-BLOCKING
{
  int in[] = {0, 90, 180};
  int out[] = {0, 84, 180};
  degree = multiMap(degree, in, out, 3);

  towerservo.startEaseToD(degree, millisForMove);
}

void driveMotors(int speed, int degree, uint16_t millisForSpeedChange = 300) //speed -90 to 90 / degrees -90 to 90, NON-BLOCKING
{
  int in[] = {-90, 0, 90};
  int left_out[] = {0, 105, 180};
  int right_out[] = {180, 106, 0};
  int speed_left = multiMap(speed + degree, in, left_out, 3);
  int speed_right = multiMap(speed - degree, in, right_out, 3);

  leftservo.startEaseToD(speed_left, millisForSpeedChange);
  rightservo.startEaseToD(speed_right, millisForSpeedChange);
}

void stopMotors()
{
  driveMotors(0, 0); //smooth stop
}

// double getRawDistance(bool direction)
// {
//   int triggerPin = FRONT_SENSOR_TRIGGER_PIN;
//   int echoPin = FRONT_SENSOR_ECHO_PIN;
//   if (direction == REAR_SENSOR)
//   {
//     triggerPin = REAR_SENSOR_TRIGGER_PIN;
//     echoPin = REAR_SENSOR_ECHO_PIN;
//   }

//   digitalWrite(triggerPin, LOW);
//   delayMicroseconds(2);
//   digitalWrite(triggerPin, HIGH);
//   delayMicroseconds(10);
//   digitalWrite(triggerPin, LOW);
//   unsigned long durationMicroSec = pulseIn(echoPin, HIGH, 6000); //timeout if over 1 m
//   double distanceCm = durationMicroSec / 2.0 * 0.0343;

//   // if (durationMicroSec == 0)
//   //   durationMicroSec = 6000;
//   // delayMicroseconds(30000 - durationMicroSec); //fill to 30000

//   if (distanceCm == 0 || distanceCm > 100)
//   {
//     return -1.0;
//   }
//   else
//   {
//     return distanceCm;
//   }
// }

// double getFilteredDistance(bool direction = FRONT_SENSOR, int smoothing = 15)
// {
//   double retVal = -1;

//   for (int i = 0; i < smoothing; i++)
//   {
//     double currentValue = getRawDistance(direction);
//     if (currentValue == -1)
//       return currentValue;
//     if (direction)
//       retVal = frontSensorFilter.updateEstimate(currentValue);
//     else
//       retVal = rearSensorFilter.updateEstimate(currentValue);
//   }

//   delay(30);
//   return retVal;
// }

void lookAround()
{
  //scan direction depending on current angle
  int startingValue = 1;
  int incrementValue = 1;
  if (towerservo.getCurrentAngle() > 90)
  {
    startingValue = 18;
    incrementValue *= -1;
  }
  for (int i = startingValue; (i <= 18 && i >= 1); i += incrementValue)
  {
    rotateTower(i * 10, 150);
    //radarData[i] = getFilteredDistance(FRONT_SENSOR, 15);
    //radarData[(18+i)%36] = getFilteredDistance(REAR_SENSOR, 15);
  }
}

void setup()
{
  // pinMode(FRONT_SENSOR_TRIGGER_PIN, OUTPUT); //dont touch for safety reasons
  // pinMode(FRONT_SENSOR_ECHO_PIN, INPUT);
  // pinMode(REAR_SENSOR_TRIGGER_PIN, OUTPUT);
  // pinMode(REAR_SENSOR_ECHO_PIN, INPUT);

  Serial.begin(115200);
  Serial2.begin(38400);
  delay(2000); //wait for serials to start

  // setTowerEasingType(EASE_QUADRATIC_IN_OUT);
  // setMotorsEasingType(EASE_QUADRATIC_IN_OUT); //EASE_LINEAR, EASE_QUADRATIC_IN_OUT, EASE_CUBIC_IN_OUT, EASE_QUARTIC_IN_OUT, EASE_CIRCULAR_IN_OUT (ALSO ONLY XXX_IN or only XXX_OUT)

  // motorsAttach();
  // stopMotors();

  // towerAttach();
  // rotateTower(90);
  // rotateTower(180);
  // rotateTower(90);
}

void loop()
{
  if (Serial2.available())
  {
    String command = Serial2.readStringUntil('#');
    command.remove(command.indexOf('\r'), 1);
    command.remove(command.indexOf('\n'), 1);
    command.remove(command.indexOf('\t'), 1);
    command.remove(command.indexOf(' '), 1);

    if (command == "LOOK_AROUND")
    {
      Serial2.println("ERROR#");
      // lookAround();
      // for (int i = 0; i < 36; i++)
      // {
      //   Serial2.print(i * 10);
      //   Serial2.print(":");
      //   Serial2.print(radarData[i], 2);
      //   Serial2.println("#");
      // }
    }
    else if (command.indexOf("TURN") != -1)
    {
      command = command.substring(command.indexOf(':') + 1);
      int value = command.toInt();
      driveMotors(0, value);
      delay(250);
      stopMotors();
    }
    else if (command.indexOf("DRIVE") != -1)
    {
      command = command.substring(command.indexOf(':') + 1);
      int value = command.toInt();
      driveMotors(value, 0);
      delay(250);
      stopMotors();
    }
    else if (command.indexOf("MOTORS_ATTACH") != -1)
      motorsAttach();
    else if (command.indexOf("MOTORS_DETACH") != -1)
      motorsDetach();
    else if (command.indexOf("TOWER_ATTACH") != -1)
      towerAttach();
    else if (command.indexOf("TOWER_DETACH") != -1)
      towerDetach();
  }
}
